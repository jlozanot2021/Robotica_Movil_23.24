# GLOBAL NAVIGATION
# -------------------------------------
Esta práctica tenía dos fases, por un lado el mapeado y por otro la navegación.

La primera parte del mapeado consistía en rellenar un mapa según el coste el cual significaba la distancia del target marcado.

Lo primero que he hecho para esta parte es crear las variables necesarias para realizar el mapeado. Las variables claves eran la posicion inicial del coche y la posición del target.

```python 
      car = HAL.getPose3d()
      position = [car.x, car.y]
      car_position = tuple(MAP.rowColumn(position))
      car_position_map = car_position
      new_target = GUI.getTargetPose()    
      new_target_map = tuple(MAP.rowColumn(new_target))
```
A partir de aquí lo que había que hacer era generar ese mapa, empezando con coste 0 en el target y rellenar hasta donde estuviese el coche (ya que es hasta donde nos interesa)
Todo esto lo he hecho con una priority_queue la cual guardaba los puntos y sus costes, una lista con los puntos ya guardados y un conjunto de casillas las cuales estaban cerca de obstáculos.
Había que mirar a los vecinos de cada casilla para continuar esta parte y guardar cada coste en el grid.


```python
  cost = 0
  position = target_map
  
  priority_queue = queue.PriorityQueue()
  priority_queue.put((cost, position))
  
  visited = set()
  visited.add(target_map)
  
  #guardar los obstaculos
  obstacles_neighbors = set(tuple(obst) for obst in obstacles_neighbors)

  #hasta que no sea la posicion del coche no para
  while position != car_start: 
    cost, position = priority_queue.get()

    # obstaculo
    if map_array[position[1], position[0]] == 0:
      grid[position[1], position[0]] = 255
      continue


    # guardar vecinos
    neighbors = []
    
    for i in range(0,1):
        neighbors.append((position[0] + i ,position[1] + 1))
        neighbors.append((position[0] + i ,position[1] - 1))
        neighbors.append((position[0] + 1 ,position[1] + i))
        neighbors.append((position[0] - 1 ,position[1] + i))
        

    for neighbor in neighbors:
      
      #mirar si ha sido visitiado
      if neighbor in visited:
        continue
        
      #fuera del mapa
      if (neighbor[0] < 0 or neighbor[0] >= map_array.shape[1] or neighbor[1] < 0 or neighbor[1] >= map_array.shape[0]):
        continue
      
      #mirar si esta cerca de un objeto
      if tuple([neighbor[1],neighbor[0]]) in obstacles_neighbors:
        obstacle_weight = WEIGHT
      else:
        obstacle_weight = 0
        
      # mirar a ver si esta en la diagonal o no
      if neighbor[0] == position[0] or neighbor[1] == position:
        grid[neighbor[1], neighbor[0]] = cost + 1
      else:
        grid[neighbor[1], neighbor[0]] = cost + math.sqrt(2)
          
      # guardar
      priority_queue.put((grid[neighbor[1], neighbor[0]], neighbor))
      #agregar peso
      grid[neighbor[1], neighbor[0]] += obstacle_weight
      visited.add(neighbor)
```


Ahora con el mapa
